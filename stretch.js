// 1. Predict the output of the code below and explain why this is the output using what you learned today. When you're ready for answers, view an explanation [here](https://www.coderbyte.com/algorithm/3-common-javascript-closure-questions

//     ```js
//     (function(){
//       var a = b = 3;
//     })();
//     console.log("a defined? " + (typeof a !== 'undefined'));
//     console.log("b defined? " + (typeof b !== 'undefined'));
//     ```
    




//     2. Write a function that would allow you to do this using a closure. (This is another interview question we've seen before - when you're ready for answers, view an explanation [here](https://www.coderbyte.com/algorithm/3-common-javascript-closure-questions)).
    
//     ```js
//     var addSix = createBase(6);
//     addSix(10); // returns 16
//     addSix(21); // returns 27
//     ```
    





//     3. Research the differences between functional programming and object oriented programming. Then, describe the pros and cons of functional programming vs object-oriented programming. This is a common interview question and great practice!
/*
    Function Oriented Programming:

    Pros:
    - Does not need to follow a certain order.
    - Less memory intensive because it is more focused on what to do instead of how its being done. 
    - Utilizes 'pure' functions without side effects and returns exactly what is expected, meaning less confusion when debugging. 

    Cons: 
    - Can become messy and hard to read without proper care. 
    - No access specifiers.
    - Hard to add new data/information.
    - Newer than OOP, harder to find documentation for.


    Object-Oriented Programming:

    Pros:
    - Very readable because it follows an order and uses methods that are easy to understand. Reads like a straight-forward set of instructions. 
    - Has three Access specifiers: Public, Private, and Protected. 
    - Very easy to add new data and infomation. 

    Cons:
    - inefficient and memory intensive. 
    - Projects can feel like they've been duplicated because modular classes are flexible and are re-used often. It's harder to make a program feel "fresh".
*/
    
    